 // scrolltext demo for Adafruit RGBmatrixPanel library.
// Demonstrates double-buffered animation on our 16x32 RGB LED matrix:
// http://www.adafruit.com/products/420

// Written by Limor Fried/Ladyada & Phil Burgess/PaintYourDragon
// for Adafruit Industries.
// BSD license, all text above must be included in any redistribution.

#include <Adafruit_GFX.h>  // Core graphics library
#include <RGBmatrixPanel.h> // Hardware-specific library


#define contactRelai 58  // patte 43,arduino n° 21, port D0  21  pour entrée 58
#define led 13           //  pour sortie

byte entree = 0 ;

// Similar to F(), but for PROGMEM string pointers rather than literals
#define F2(progmem_ptr) (const __FlashStringHelper *)progmem_ptr

#define CLK 11  // MUST be on PORTB! (Use pin 11 on Mega)
#define LAT A3
#define OE  9
#define A   A0
#define B   A1
#define C   A2

#define NUMDISPLAYS 2
#define DOUBLEBUFFER true

const char complet[] PROGMEM = "COMPLET";
const char libre[]  PROGMEM = "LIBRE";

RGBmatrixPanel matrix(A, B, C, CLK, LAT, OE, DOUBLEBUFFER, NUMDISPLAYS);

static const uint16_t PROGMEM Color[5] = {
  0x0F00, // vert  =0
  0x00F0, // Bleu  =1
  0xF000, // Rouge =2
  0xFFFF, // Blanc =3
  0xFFA5 //  Ambre =4
};
int commande = 0;
byte i = 0; //permet le comptage du nombre de defillement sevenpark au demarrage

int    textX         = matrix.width(),
       textX2        = 0,
       textMin       = sizeof(complet) * -50,
       hue     = 0;;
#define LOGO16_GLCD_HEIGHT 64
#define LOGO16_GLCD_WIDTH  16 
/*
const unsigned char Complet [] PROGMEM = {
  // 'COMPLET'
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x06, 0x18, 0x6f, 0x86, 0x07, 0xf7, 0xfe, 
  0x3f, 0x0f, 0x18, 0x6f, 0xc6, 0x07, 0xf7, 0xfe, 0x33, 0x9f, 0x98, 0x6c, 0xe6, 0x06, 0x00, 0x60, 
  0x71, 0x99, 0x98, 0x6c, 0x76, 0x06, 0x00, 0x60, 0x60, 0x30, 0xdc, 0xec, 0x36, 0x06, 0x00, 0x60, 
  0x60, 0x30, 0xdf, 0xec, 0x76, 0x06, 0x00, 0x60, 0x60, 0x30, 0xdf, 0xec, 0xe6, 0x07, 0xc0, 0x60, 
  0x60, 0x30, 0xdf, 0xef, 0xc6, 0x07, 0xc0, 0x60, 0x60, 0x30, 0xdb, 0x6f, 0x86, 0x06, 0x00, 0x60, 
  0x60, 0x30, 0xd8, 0x6c, 0x06, 0x06, 0x00, 0x60, 0x71, 0x99, 0x98, 0x6c, 0x06, 0x06, 0x00, 0x60, 
  0x33, 0x9f, 0x98, 0x6c, 0x06, 0x06, 0x00, 0x60, 0x3f, 0x0f, 0x18, 0x6c, 0x07, 0xf7, 0xf0, 0x60, 
  0x1e, 0x06, 0x18, 0x6c, 0x07, 0xf7, 0xf0, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
};

const unsigned char Libre [] PROGMEM = {
  // 'LIBRE'
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x0f, 0xdf, 0x8f, 0x87, 0xf0, 0x00, 
  0x00, 0x18, 0x0f, 0xdf, 0x8f, 0xc7, 0xf0, 0x00, 0x00, 0x18, 0x03, 0x19, 0xcc, 0xe6, 0x00, 0x00, 
  0x00, 0x18, 0x03, 0x18, 0xcc, 0x66, 0x00, 0x00, 0x00, 0x18, 0x03, 0x18, 0xcc, 0x66, 0x00, 0x00, 
  0x00, 0x18, 0x03, 0x19, 0xcc, 0xe6, 0x00, 0x00, 0x00, 0x18, 0x03, 0x1f, 0x8f, 0xc7, 0xc0, 0x00, 
  0x00, 0x18, 0x03, 0x1f, 0xcf, 0x87, 0xc0, 0x00, 0x00, 0x18, 0x03, 0x18, 0xef, 0x86, 0x00, 0x00, 
  0x00, 0x18, 0x03, 0x18, 0x6d, 0xc6, 0x00, 0x00, 0x00, 0x18, 0x03, 0x18, 0x6c, 0xe6, 0x00, 0x00, 
  0x00, 0x18, 0x03, 0x18, 0xec, 0x76, 0x00, 0x00, 0x00, 0x1f, 0xef, 0xdf, 0xcc, 0x37, 0xf0, 0x00, 
  0x00, 0x1f, 0xef, 0xdf, 0x8c, 0x37, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
};
*/

void setup() {
  
  matrix.begin();
  matrix.setTextSize(2);
  //  pour commande par le relai
  pinMode(contactRelai, INPUT);         // entree relai
  digitalWrite(contactRelai, HIGH) ;    // pull up
  pinMode(led, OUTPUT) ;

   
}  //  fin setup -----

void loop() {



      if (digitalRead(contactRelai) == 0)
         {
           digitalWrite(led,HIGH);
           commande=2;
           Fct_complet();
         }
      else
        {
          digitalWrite(led,LOW);  
          commande=1;
          Fct_libre(); 
          matrix.swapBuffers(true);
    
        }
}

void Fct_libre(){
    while (commande==1){
           
          matrix.fillScreen(0);  
          matrix.setTextColor(pgm_read_word(&Color[0]));
          matrix.setCursor(textX, 1);
          matrix.print(F2(libre));  //F2(str)
        
          // Move text left (w/wrap), increase hue
          if((--textX) < textMin){ textX = matrix.width(); i++;}
          
          // Update display
          matrix.swapBuffers(false);
          //Fct_receptionRS485();
    }
}  

void Fct_complet(){
 
   while (commande==2){
   
        matrix.fillScreen(0);  
        matrix.setTextColor(pgm_read_word(&Color[2]));
        matrix.setCursor(textX, 1);
        matrix.print(F2(complet));  //F2(str)
      
        // Move text left (w/wrap), increase hue
        if((--textX) < textMin){ textX = matrix.width(); i++;}
        
        // Update display
        matrix.swapBuffers(false);
        //Fct_receptionRS485();
  
     }
  }
